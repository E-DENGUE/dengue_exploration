---
title: "Model Building"
author: "Elisabeth Nelson"
date: "2022-10-20"
output: pdf_document
---
## Load Packages
```{r}
#library(rjags)
library(MCMCpack)
library(stats)
library(CARBayes) # <- this is the package for the model
library(rgdal) # <- for working with shapefiles
library(RColorBrewer) 
library(ggplot2)
library(rgeos) # <- also for working with shapefiles
library(maptools) # shapefiles again
library(spdep) # still shapefiles 
library(ggmap) # plotting shapefiles 
library(sf)
library(dplyr)
library(tidyverse)
library(CARBayesST)

# parallel processing
## figure out which packages are needed
# state data frame being input
# call jags would be mod_func
# n_advance --> look up do function
# look up what collect does
# likely stored in a list of fitted model outputs
# try talkin gto help desk about cluster

# try running it once 

```


## Set-up for Carbays
```{r}
# Number of spatial units (e.g., districts in MDR)
n.district <- 134
n.district2 <- 132

# Create an n x􏰀 n identity matrix
Id.mat <- diag(n.district)
Id.mat2 <- diag(n.district2)

MDR_2 <- st_read(dsn = '/Users/zoe/Documents/Yale EMD/Rotation 1/Dengue - Vietnam/dengue_exploration/Data/MDR Updated map/VMD_districts_2022.shp')

MDR_3 <- MDR_2 %>%
  filter(VARNAME_2 != "Kien Hai", 
         VARNAME_2 != "Phu Quoc")
```

## Neighbor Matrix
```{r}
# Neighbors can either be Queen (any zip that touches another zip - even at 
# corners) or Rook neighbors (share full sides -- not corners)

# The snap dist is governing the NA in neighbor matrix
# Can remove SNAP statement; if Queen = F then single point touch not allowed 
# and Rook distance used.

# When data is missing -- there's more non-zero links involved 
# Try to make snap distance as small as possible while making sure all states 
# have at least one neighbor
neighb <- poly2nb(MDR_2, queen = T, snap = sqrt(0.001))


# Check average number of links -- increase snap distance if it says there is 
# a zip with zero neighbors
neighb # Avg Number of links = 5.19403 
  # regions 74 nand 76 have no links --> islands Kien Hai/District + Phu Quoc/City


# Make neighbor matrix 
# if zero.policy FALSE stop with error for any empty neighbour sets, 
# if TRUE permit the weights list to be formed with zero-length weights vectors
# B is the basic binary coding, W is row standardised (both are commonly used)
neighb.mat <- nb2mat(neighb, zero.policy = T, style = 'B')


# the islands will not have neighbors, so need to exclude it at first (islands Kien Hai/District + Phu Quoc/City)
neighb2 <- poly2nb(MDR_3, queen = T, snap = sqrt(0.001))
neighb2
neighb.mat_2 <- nb2mat(neighb2, zero.policy = T, style = 'B')


# For Leroux model, neighbor matrix needs to have 0 if not neighboring, -1 if 
# neighbor, and # of neighbors for each state on diagonal), so...
w.mat <- ifelse(neighb.mat==1,-1,neighb.mat)
num.neigh <- colSums(neighb.mat) # Count the number of neighbors for each state
for (i in 1:nrow(w.mat)) { # Put the number of neighbors on diagonal
  for (j in 1:ncol(w.mat)) {
    if (i==j) {
      w.mat[i,j] <- num.neigh[i]
    }
  }
}
# w.mat <- array(NA, dim=c(n.stzipcode,n.zipcode,n.countries))
# w.mat[,,1] <- ifelse(neighb.mat==1,-1,neighb.mat) # Replace 1 with -1
# num.neigh <- colSums(neighb.mat) # Count the number of neighbors for each state
# for (i in 1:nrow(w.mat[,,1])) { # Put the number of neighbors on diagonal
#   for (j in 1:ncol(w.mat[,,1])) {
#     if (i==j) {
#       w.mat[i,j,1] <- num.neigh[i]
#     }
#   }
# }


# could eventually define neighbors for the islands based on spatial adjacency/transport
# could also separately analyze them once we have a model and see if it predcits well in them independently

```

## Create an Aggregated DF With Distinct District Names 
```{r}

# create data frame
base_model_2001_2006_agg <- fortify(MDR_Dengue_map) 

base_model_2001_2006_agg_2 <- base_model_2001_2006_agg %>%
  filter(NAME_1 == "An Giang" & VARNAME_2 == "Chau Thanh") %>%
  mutate(VARNAME_2 = str_replace(VARNAME_2, "Chau Thanh", "Chau Thanh An Giang"))

base_model_2001_2006_agg_3 <- base_model_2001_2006_agg %>%
  filter(NAME_1 == "Bến Tre" & VARNAME_2 == "Chau Thanh") %>%
  mutate(VARNAME_2 = str_replace(VARNAME_2, "Chau Thanh", "Chau Thanh Ben Tre"))

base_model_2001_2006_agg_4 <- base_model_2001_2006_agg %>%
  filter(NAME_1 == "Đồng Tháp" & VARNAME_2 == "Chau Thanh") %>%
  mutate(VARNAME_2 = str_replace(VARNAME_2, "Chau Thanh", "Chau Thanh Dong Thanp"))

base_model_2001_2006_agg_5 <- base_model_2001_2006_agg %>%
  filter(NAME_1 == "Hậu Giang" & VARNAME_2 == "Chau Thanh") %>%
  mutate(VARNAME_2 = str_replace(VARNAME_2, "Chau Thanh", "Chau Thanh Hau Giang"))

base_model_2001_2006_agg_6 <- base_model_2001_2006_agg %>%
  filter(NAME_1 == "Kiên Giang" & VARNAME_2 == "Chau Thanh") %>%
  mutate(VARNAME_2 = str_replace(VARNAME_2, "Chau Thanh", "Chau Thanh Kien Giang"))

base_model_2001_2006_agg_7 <- base_model_2001_2006_agg %>%
  filter(NAME_1 == "Long An" & VARNAME_2 == "Chau Thanh") %>%
  mutate(VARNAME_2 = str_replace(VARNAME_2, "Chau Thanh", "Chau Thanh Long An"))
 
base_model_2001_2006_agg_8 <- base_model_2001_2006_agg %>%
  filter(NAME_1 == "Sóc Trăng" & VARNAME_2 == "Chau Thanh") %>%
  mutate(VARNAME_2 = str_replace(VARNAME_2, "Chau Thanh", "Chau Thanh Soc Trang")) 
         
base_model_2001_2006_agg_9 <- base_model_2001_2006_agg %>%
  filter(NAME_1 == "Tiền Giang" & VARNAME_2 == "Chau Thanh") %>%
  mutate(VARNAME_2 = str_replace(VARNAME_2, "Chau Thanh", "Chau Thanh Tien Giang"))

base_model_2001_2006_agg_10 <- base_model_2001_2006_agg %>%
  filter(NAME_1 == "Trà Vinh" & VARNAME_2 == "Chau Thanh") %>%
  mutate(VARNAME_2 = str_replace(VARNAME_2, "Chau Thanh", "Chau Thanh Tra Vinh"))

base_model_2001_2006_agg_11 <- base_model_2001_2006_agg %>%
  filter(NAME_1 == "An Giang" & VARNAME_2 == "Phu Tan") %>%
  mutate(VARNAME_2 = str_replace(VARNAME_2, "Phu Tan", "Phu Tan An Giang")) 
      
base_model_2001_2006_agg_12 <- base_model_2001_2006_agg %>%
  filter(NAME_1 == "Cà Mau" & VARNAME_2 == "Phu Tan") %>%
  mutate(VARNAME_2 = str_replace(VARNAME_2, "Phu Tan", "Phu Tan Ca Mau"))

base_model_2001_2006_agg_13 <- base_model_2001_2006_agg %>%
  filter(NAME_1 == "Đồng Tháp" & VARNAME_2 == "Cao Lanh" & district == "cao lãnh") %>%
  mutate(VARNAME_2 = str_replace(VARNAME_2, "Cao Lanh", "Cao Lanh District"))

base_model_2001_2006_agg_14 <- base_model_2001_2006_agg %>%
  filter(NAME_1 == "Đồng Tháp" & VARNAME_2 == "Cao Lanh" & ENGTYPE_2 == "City") %>%
  mutate(VARNAME_2 = str_replace(VARNAME_2, "Cao Lanh", "Cao Lanh City"))

base_model_2001_2006_agg_15 <- base_model_2001_2006_agg %>%
  filter(NAME_1 == "Đồng Tháp" & VARNAME_2 == "Hong Ngu" & district == "hồng ngự") %>%
  mutate(VARNAME_2 = str_replace(VARNAME_2, "Hong Ngu", "Hong Ngu District"))

base_model_2001_2006_agg_16 <- base_model_2001_2006_agg %>%
  filter(NAME_1 == "Đồng Tháp" & VARNAME_2 == "Hong Ngu" & ENGTYPE_2 == "City") %>%
  mutate(VARNAME_2 = str_replace(VARNAME_2, "Hong Ngu", "Hong Ngu City"))

base_model_2001_2006_agg_17 <- base_model_2001_2006_agg %>%
  filter(NAME_1 == "Hậu Giang" & VARNAME_2 == "Long My" & district == "long mỹ") %>%
  mutate(VARNAME_2 = str_replace(VARNAME_2, "Long My", "Long My District"))

base_model_2001_2006_agg_18 <- base_model_2001_2006_agg %>%
  filter(NAME_1 == "Hậu Giang" & VARNAME_2 == "Long My" & ENGTYPE_2 == "Town") %>%
  mutate(VARNAME_2 = str_replace(VARNAME_2, "Long My", "Long My Town"))

base_model_2001_2006_agg_19 <- base_model_2001_2006_agg %>%
  filter(NAME_1 == "Tiền Giang" & VARNAME_2 == "Cai Lay" & district == "cai lậy") %>%
  mutate(VARNAME_2 = str_replace(VARNAME_2, "Cai Lay", "Cai Lay District"))

base_model_2001_2006_agg_20 <- base_model_2001_2006_agg %>%
  filter(NAME_1 == "Tiền Giang" & VARNAME_2 == "Cai Lay" & ENGTYPE_2 == "Town") %>%
  mutate(VARNAME_2 = str_replace(VARNAME_2, "Cai Lay", "Cai Lay Town"))

base_model_2001_2006_agg_21 <- base_model_2001_2006_agg %>%
  filter(NAME_1 == "Trà Vinh" & VARNAME_2 == "Duyen Hai" & district == "duyên hải") %>%
  mutate(VARNAME_2 = str_replace(VARNAME_2, "Duyen Hai", "Duyen Hai District"))

base_model_2001_2006_agg_22 <- base_model_2001_2006_agg %>%
  filter(NAME_1 == "Trà Vinh" & VARNAME_2 == "Duyen Hai" & ENGTYPE_2 == "Town") %>%
  mutate(VARNAME_2 = str_replace(VARNAME_2, "Duyen Hai", "Duyen Hai Town"))

base_model_2001_2006_agg_filter <- rbind(base_model_2001_2006_agg, base_model_2001_2006_agg_2, base_model_2001_2006_agg_3, base_model_2001_2006_agg_4, base_model_2001_2006_agg_5, base_model_2001_2006_agg_6, base_model_2001_2006_agg_7, base_model_2001_2006_agg_8, base_model_2001_2006_agg_9, base_model_2001_2006_agg_10, base_model_2001_2006_agg_11, base_model_2001_2006_agg_12, base_model_2001_2006_agg_13, base_model_2001_2006_agg_14, base_model_2001_2006_agg_15, base_model_2001_2006_agg_16, base_model_2001_2006_agg_17, base_model_2001_2006_agg_18, base_model_2001_2006_agg_19, base_model_2001_2006_agg_20, base_model_2001_2006_agg_21, base_model_2001_2006_agg_22)

names_to_delete <- c("Chau Thanh", "Phu Tan", "Cao Lanh", "Hong Ngu", "Long My", "Cai Lay", "Duyen Hai")

base_model_2001_2006_agg_filter <- base_model_2001_2006_agg_filter %>%
  filter(!(VARNAME_2 %in% names_to_delete))

# rotate month variables into one column
base_model_2001_2006_filter_long <- base_model_2001_2006_agg_filter %>%
  pivot_longer(cols = starts_with("m"), 
               values_to = "m_DHF_cases", 
               names_to = "month")

# fill-in missing years
agg1 <- base_model_2001_2006_filter_long %>%
  #bind_rows() %>% 
  #group_by(VARNAME_2, year, month) %>%
  #summarize(m_DHF_cases = n())  %>%
  #ungroup  %>%
  mutate(month=as.factor(month),
 year=as.factor(year),
 district =as.factor(VARNAME_2)) %>%
  tidyr::complete(year, month, VARNAME_2, fill=list(m_DHF_cases=NA)) #fills NA

base_model_final <- agg1 %>%
  mutate(month = as.numeric(month),
    m_DHF_cases = as.numeric(m_DHF_cases))


```

## Test to make sure data is ready for model (should all be the same number)
```{r}
for(j in 1: length(unique(base_model_2001_2006_agg_filter$VARNAME_2))){
  print(sum(base_model_2001_2006_agg_filter$VARNAME_2 == unique(base_model_2001_2006_agg_filter$VARNAME_2)[j]))
  if( sum(base_model_2001_2006_agg_filter$VARNAME_2 == unique(base_model_2001_2006_agg_filter$VARNAME_2)[j]) != 18) {
    print(unique(base_model_2001_2006_agg_filter$VARNAME_2)[j])
  }
}



```

## Function for generating dataset
```{r}

#initially, fit htough nov 2006, set dec 2006 to NA
#'2006-12-01'


advance_missing_func <- function(N_advance){
      
      base_model_for_model_1 <- base_model_final %>% 
        mutate(year = unfactor(year),
               #monthN = as.numeric(gsub('m','', month)),
               date = as.Date(paste(year, month, '01', sep='-')),
               pop=if_else(is.na(pop), 0.5 ,pop)) %>%
        filter( date <= (as.Date('2006-12-01' ) %m+% months(N_advance) )) %>%
        arrange(district, date) %>%
        group_by(district) %>%
        mutate( m_DHF_cases=if_else(is.na(m_DHF_cases),0, m_DHF_cases), ##ALERT...assuming nov, dec missing=0
          index= row_number() , 
               m_DHF_cases_fit = if_else(index==max(index,na.rm=T), NA_real_,m_DHF_cases) ) %>%
        filter(VARNAME_2 != "Kien Hai", 
         VARNAME_2 != "Phu Quoc") %>%
        dplyr::select(month, year, district, m_DHF_cases,m_DHF_cases_fit, pop)
}

ds <- advance_missing_func(0)
#ds.advance <- lapply(0:10, advance_missing_func)
```


## Base Model (based on code from Josh)
```{r}
###############################################################

#Model Fitting

###############################################################

# default of burnin = 10000, n.sample = 110000, thin = 10

mod.func <- function(N_advance) {
  ds <- advance_missing_func(N_advance) 
 
  x_model = model.matrix(~ as.factor(as.numeric(month)), data = ds)

  offset_model = log(ds$pop)


  results<-ST.CARar(m_DHF_cases_fit ~ -1 + x_model + offset(offset_model) , 
                  data = ds,

                  family = "poisson",

                  W = neighb.mat_2,

                  burnin = 10, 

                  n.sample = 100,

                  thin = 5,

                  prior.mean.beta = rep(0,

                                        times = ncol(x_model)),
                                        
                  prior.var.beta = rep((100^2),

                                       times = ncol(x_model)),

                  prior.tau2 = c(0.01, 0.01),
                  
                  AR = 1,

                  MALA = TRUE,

                  verbose = TRUE)
}

mod1 <- mod.func(1)


results$summary.results

# want to look at the trace plots for seasonality, overall fitted value (probably won't converge with lower numbers of runs)


```
Should we be using our past model as the next model's prior?

